{"ast":null,"code":"import { toast } from 'react-toastify';\nclass NotificationService {\n  constructor() {\n    this.checkPermission();\n    this.notifications = [];\n    this.initialized = false;\n    this.debugMode = true; // Enable debug mode\n  }\n\n  // Check if browser notifications are supported and permission is granted\n  checkPermission() {\n    this.hasSupport = 'Notification' in window;\n    this.permission = this.hasSupport ? Notification.permission : 'denied';\n    return this.permission === 'granted';\n  }\n\n  // Request permission for browser notifications\n  async requestPermission() {\n    if (!this.hasSupport) {\n      console.log('Browser notifications not supported');\n      return false;\n    }\n    try {\n      if (this.permission !== 'granted') {\n        const permission = await Notification.requestPermission();\n        this.permission = permission;\n        console.log(`Notification permission: ${permission}`);\n        return permission === 'granted';\n      }\n      return true;\n    } catch (error) {\n      console.error('Error requesting notification permission:', error);\n      return false;\n    }\n  }\n\n  // Initialize the notification service\n  async initialize() {\n    if (this.initialized) return;\n    try {\n      const hasPermission = await this.requestPermission();\n      if (hasPermission) {\n        console.log('Notification permission granted');\n        // Send a test notification to confirm it's working\n        if (this.debugMode) {\n          this.showTestNotification();\n        }\n      } else {\n        console.log('Notification permission denied');\n      }\n      this.initialized = true;\n    } catch (error) {\n      console.error('Error initializing notification service:', error);\n    }\n  }\n\n  // Show a test notification\n  showTestNotification() {\n    const title = 'Notification Test';\n    const options = {\n      body: 'Notifications are working correctly!',\n      icon: '/logo192.png'\n    };\n\n    // Show browser notification\n    if (this.permission === 'granted') {\n      try {\n        new Notification(title, options);\n      } catch (error) {\n        console.error('Error showing browser notification:', error);\n      }\n    }\n\n    // Always show toast notification (for debug only)\n    // toast.info('Notification system initialized successfully', {\n    //   autoClose: 3000\n    // });\n  }\n\n  // Schedule a notification for an appointment\n  scheduleNotification(appointment) {\n    if (!appointment || !appointment.date) return;\n    try {\n      const appointmentDate = new Date(appointment.date);\n      const [hours, minutes] = appointment.startTime.split(':').map(Number);\n      appointmentDate.setHours(hours, minutes);\n\n      // For debugging: show notification 10 seconds from now if in debug mode\n      let notificationTime;\n      if (this.debugMode) {\n        var _appointment$service;\n        notificationTime = new Date(Date.now() + 10000); // 10 seconds from now\n        console.log(`Debug: Scheduling notification for ${(_appointment$service = appointment.service) === null || _appointment$service === void 0 ? void 0 : _appointment$service.name} in 10 seconds`);\n      } else {\n        // Schedule notification 1 hour before appointment\n        notificationTime = new Date(appointmentDate.getTime() - 60 * 60 * 1000);\n      }\n      const now = new Date();\n\n      // Only schedule if the notification time is in the future\n      if (notificationTime > now) {\n        const timeUntilNotification = notificationTime.getTime() - now.getTime();\n        console.log(`Scheduling notification for ${timeUntilNotification}ms from now`);\n\n        // Store notification info\n        const notificationId = setTimeout(() => {\n          this.showNotification(appointment);\n        }, timeUntilNotification);\n        this.notifications.push({\n          id: notificationId,\n          appointment,\n          time: notificationTime\n        });\n        return notificationId;\n      } else {\n        console.log('Notification time is in the past, not scheduling');\n      }\n    } catch (error) {\n      console.error('Error scheduling notification:', error);\n    }\n    return null;\n  }\n\n  // Cancel a scheduled notification\n  cancelNotification(notificationId) {\n    clearTimeout(notificationId);\n    this.notifications = this.notifications.filter(n => n.id !== notificationId);\n  }\n\n  // Show a notification for an appointment\n  showNotification(appointment) {\n    try {\n      var _appointment$user, _appointment$service2, _appointment$business;\n      // Get user info from appointment context to determine messaging\n      const isBusinessAppointment = appointment.business && appointment.user && window.localStorage.getItem('userId') === appointment.business._id;\n\n      // Different content based on user context\n      const title = isBusinessAppointment ? `Upcoming Appointment with ${((_appointment$user = appointment.user) === null || _appointment$user === void 0 ? void 0 : _appointment$user.name) || 'Client'}` : `Upcoming Appointment: ${((_appointment$service2 = appointment.service) === null || _appointment$service2 === void 0 ? void 0 : _appointment$service2.name) || 'Appointment'}`;\n      const body = isBusinessAppointment ? `You have an appointment scheduled in 1 hour at ${appointment.startTime}.` : `Your appointment with ${((_appointment$business = appointment.business) === null || _appointment$business === void 0 ? void 0 : _appointment$business.name) || 'Provider'} is in 1 hour at ${appointment.startTime}.`;\n      const options = {\n        body,\n        icon: '/logo192.png'\n      };\n      console.log('Showing notification:', title);\n\n      // Show browser notification if permission granted\n      if (this.permission === 'granted') {\n        new Notification(title, options);\n      }\n\n      // Always show toast notification\n      toast.info(title + '\\n' + options.body, {\n        autoClose: 10000 // 10 seconds\n      });\n    } catch (error) {\n      console.error('Error showing notification:', error);\n      // Fallback to toast notification\n      toast.info('You have an upcoming appointment', {\n        autoClose: 5000\n      });\n    }\n  }\n\n  // Schedule notifications for all upcoming appointments\n  scheduleAppointmentNotifications(appointments) {\n    if (!appointments || !Array.isArray(appointments)) return;\n    try {\n      // Initialize the notification service if not already initialized\n      if (!this.initialized) {\n        this.initialize();\n      }\n\n      // Clear existing notifications\n      this.clearAllNotifications();\n\n      // Schedule new notifications for upcoming appointments\n      const upcomingAppointments = appointments.filter(appointment => appointment.status === 'scheduled' && new Date(appointment.date) > new Date());\n      console.log(`Scheduling notifications for ${upcomingAppointments.length} upcoming appointments`);\n      upcomingAppointments.forEach(appointment => {\n        this.scheduleNotification(appointment);\n      });\n\n      // For debugging: if no upcoming appointments and in debug mode, show a test notification\n      if (upcomingAppointments.length === 0 && this.debugMode) {\n        setTimeout(() => {\n          this.showTestNotification();\n        }, 5000);\n      }\n    } catch (error) {\n      console.error('Error scheduling appointment notifications:', error);\n    }\n  }\n\n  // Clear all scheduled notifications\n  clearAllNotifications() {\n    this.notifications.forEach(notification => {\n      clearTimeout(notification.id);\n    });\n    this.notifications = [];\n    console.log('All notifications cleared');\n  }\n}\n\n// Create a singleton instance\nconst notificationService = new NotificationService();\nexport default notificationService;","map":{"version":3,"names":["toast","NotificationService","constructor","checkPermission","notifications","initialized","debugMode","hasSupport","window","permission","Notification","requestPermission","console","log","error","initialize","hasPermission","showTestNotification","title","options","body","icon","scheduleNotification","appointment","date","appointmentDate","Date","hours","minutes","startTime","split","map","Number","setHours","notificationTime","_appointment$service","now","service","name","getTime","timeUntilNotification","notificationId","setTimeout","showNotification","push","id","time","cancelNotification","clearTimeout","filter","n","_appointment$user","_appointment$service2","_appointment$business","isBusinessAppointment","business","user","localStorage","getItem","_id","info","autoClose","scheduleAppointmentNotifications","appointments","Array","isArray","clearAllNotifications","upcomingAppointments","status","length","forEach","notification","notificationService"],"sources":["D:/Appointment Scheduler/client/src/services/NotificationService.js"],"sourcesContent":["import { toast } from 'react-toastify';\n\nclass NotificationService {\n  constructor() {\n    this.checkPermission();\n    this.notifications = [];\n    this.initialized = false;\n    this.debugMode = true; // Enable debug mode\n  }\n\n  // Check if browser notifications are supported and permission is granted\n  checkPermission() {\n    this.hasSupport = 'Notification' in window;\n    this.permission = this.hasSupport ? Notification.permission : 'denied';\n    return this.permission === 'granted';\n  }\n\n  // Request permission for browser notifications\n  async requestPermission() {\n    if (!this.hasSupport) {\n      console.log('Browser notifications not supported');\n      return false;\n    }\n    \n    try {\n      if (this.permission !== 'granted') {\n        const permission = await Notification.requestPermission();\n        this.permission = permission;\n        console.log(`Notification permission: ${permission}`);\n        return permission === 'granted';\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error requesting notification permission:', error);\n      return false;\n    }\n  }\n\n  // Initialize the notification service\n  async initialize() {\n    if (this.initialized) return;\n    \n    try {\n      const hasPermission = await this.requestPermission();\n      \n      if (hasPermission) {\n        console.log('Notification permission granted');\n        // Send a test notification to confirm it's working\n        if (this.debugMode) {\n          this.showTestNotification();\n        }\n      } else {\n        console.log('Notification permission denied');\n      }\n      \n      this.initialized = true;\n    } catch (error) {\n      console.error('Error initializing notification service:', error);\n    }\n  }\n\n  // Show a test notification\n  showTestNotification() {\n    const title = 'Notification Test';\n    const options = {\n      body: 'Notifications are working correctly!',\n      icon: '/logo192.png'\n    };\n    \n    // Show browser notification\n    if (this.permission === 'granted') {\n      try {\n        new Notification(title, options);\n      } catch (error) {\n        console.error('Error showing browser notification:', error);\n      }\n    }\n    \n    // Always show toast notification (for debug only)\n    // toast.info('Notification system initialized successfully', {\n    //   autoClose: 3000\n    // });\n  }\n\n  // Schedule a notification for an appointment\n  scheduleNotification(appointment) {\n    if (!appointment || !appointment.date) return;\n    \n    try {\n      const appointmentDate = new Date(appointment.date);\n      const [hours, minutes] = appointment.startTime.split(':').map(Number);\n      appointmentDate.setHours(hours, minutes);\n      \n      // For debugging: show notification 10 seconds from now if in debug mode\n      let notificationTime;\n      if (this.debugMode) {\n        notificationTime = new Date(Date.now() + 10000); // 10 seconds from now\n        console.log(`Debug: Scheduling notification for ${appointment.service?.name} in 10 seconds`);\n      } else {\n        // Schedule notification 1 hour before appointment\n        notificationTime = new Date(appointmentDate.getTime() - 60 * 60 * 1000);\n      }\n      \n      const now = new Date();\n      \n      // Only schedule if the notification time is in the future\n      if (notificationTime > now) {\n        const timeUntilNotification = notificationTime.getTime() - now.getTime();\n        console.log(`Scheduling notification for ${timeUntilNotification}ms from now`);\n        \n        // Store notification info\n        const notificationId = setTimeout(() => {\n          this.showNotification(appointment);\n        }, timeUntilNotification);\n        \n        this.notifications.push({\n          id: notificationId,\n          appointment,\n          time: notificationTime\n        });\n        \n        return notificationId;\n      } else {\n        console.log('Notification time is in the past, not scheduling');\n      }\n    } catch (error) {\n      console.error('Error scheduling notification:', error);\n    }\n    \n    return null;\n  }\n\n  // Cancel a scheduled notification\n  cancelNotification(notificationId) {\n    clearTimeout(notificationId);\n    this.notifications = this.notifications.filter(n => n.id !== notificationId);\n  }\n\n  // Show a notification for an appointment\n  showNotification(appointment) {\n    try {\n      // Get user info from appointment context to determine messaging\n      const isBusinessAppointment = appointment.business && \n        appointment.user && \n        window.localStorage.getItem('userId') === appointment.business._id;\n      \n      // Different content based on user context\n      const title = isBusinessAppointment\n        ? `Upcoming Appointment with ${appointment.user?.name || 'Client'}`\n        : `Upcoming Appointment: ${appointment.service?.name || 'Appointment'}`;\n      \n      const body = isBusinessAppointment\n        ? `You have an appointment scheduled in 1 hour at ${appointment.startTime}.`\n        : `Your appointment with ${appointment.business?.name || 'Provider'} is in 1 hour at ${appointment.startTime}.`;\n      \n      const options = {\n        body,\n        icon: '/logo192.png'\n      };\n      \n      console.log('Showing notification:', title);\n      \n      // Show browser notification if permission granted\n      if (this.permission === 'granted') {\n        new Notification(title, options);\n      }\n      \n      // Always show toast notification\n      toast.info(title + '\\n' + options.body, {\n        autoClose: 10000 // 10 seconds\n      });\n    } catch (error) {\n      console.error('Error showing notification:', error);\n      // Fallback to toast notification\n      toast.info('You have an upcoming appointment', {\n        autoClose: 5000\n      });\n    }\n  }\n\n  // Schedule notifications for all upcoming appointments\n  scheduleAppointmentNotifications(appointments) {\n    if (!appointments || !Array.isArray(appointments)) return;\n    \n    try {\n      // Initialize the notification service if not already initialized\n      if (!this.initialized) {\n        this.initialize();\n      }\n      \n      // Clear existing notifications\n      this.clearAllNotifications();\n      \n      // Schedule new notifications for upcoming appointments\n      const upcomingAppointments = appointments.filter(appointment => \n        appointment.status === 'scheduled' && \n        new Date(appointment.date) > new Date()\n      );\n      \n      console.log(`Scheduling notifications for ${upcomingAppointments.length} upcoming appointments`);\n      \n      upcomingAppointments.forEach(appointment => {\n        this.scheduleNotification(appointment);\n      });\n      \n      // For debugging: if no upcoming appointments and in debug mode, show a test notification\n      if (upcomingAppointments.length === 0 && this.debugMode) {\n        setTimeout(() => {\n          this.showTestNotification();\n        }, 5000);\n      }\n    } catch (error) {\n      console.error('Error scheduling appointment notifications:', error);\n    }\n  }\n\n  // Clear all scheduled notifications\n  clearAllNotifications() {\n    this.notifications.forEach(notification => {\n      clearTimeout(notification.id);\n    });\n    this.notifications = [];\n    console.log('All notifications cleared');\n  }\n}\n\n// Create a singleton instance\nconst notificationService = new NotificationService();\n\nexport default notificationService; "],"mappings":"AAAA,SAASA,KAAK,QAAQ,gBAAgB;AAEtC,MAAMC,mBAAmB,CAAC;EACxBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,eAAe,CAAC,CAAC;IACtB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,SAAS,GAAG,IAAI,CAAC,CAAC;EACzB;;EAEA;EACAH,eAAeA,CAAA,EAAG;IAChB,IAAI,CAACI,UAAU,GAAG,cAAc,IAAIC,MAAM;IAC1C,IAAI,CAACC,UAAU,GAAG,IAAI,CAACF,UAAU,GAAGG,YAAY,CAACD,UAAU,GAAG,QAAQ;IACtE,OAAO,IAAI,CAACA,UAAU,KAAK,SAAS;EACtC;;EAEA;EACA,MAAME,iBAAiBA,CAAA,EAAG;IACxB,IAAI,CAAC,IAAI,CAACJ,UAAU,EAAE;MACpBK,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;MAClD,OAAO,KAAK;IACd;IAEA,IAAI;MACF,IAAI,IAAI,CAACJ,UAAU,KAAK,SAAS,EAAE;QACjC,MAAMA,UAAU,GAAG,MAAMC,YAAY,CAACC,iBAAiB,CAAC,CAAC;QACzD,IAAI,CAACF,UAAU,GAAGA,UAAU;QAC5BG,OAAO,CAACC,GAAG,CAAC,4BAA4BJ,UAAU,EAAE,CAAC;QACrD,OAAOA,UAAU,KAAK,SAAS;MACjC;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOK,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;MACjE,OAAO,KAAK;IACd;EACF;;EAEA;EACA,MAAMC,UAAUA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACV,WAAW,EAAE;IAEtB,IAAI;MACF,MAAMW,aAAa,GAAG,MAAM,IAAI,CAACL,iBAAiB,CAAC,CAAC;MAEpD,IAAIK,aAAa,EAAE;QACjBJ,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;QAC9C;QACA,IAAI,IAAI,CAACP,SAAS,EAAE;UAClB,IAAI,CAACW,oBAAoB,CAAC,CAAC;QAC7B;MACF,CAAC,MAAM;QACLL,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;MAC/C;MAEA,IAAI,CAACR,WAAW,GAAG,IAAI;IACzB,CAAC,CAAC,OAAOS,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;IAClE;EACF;;EAEA;EACAG,oBAAoBA,CAAA,EAAG;IACrB,MAAMC,KAAK,GAAG,mBAAmB;IACjC,MAAMC,OAAO,GAAG;MACdC,IAAI,EAAE,sCAAsC;MAC5CC,IAAI,EAAE;IACR,CAAC;;IAED;IACA,IAAI,IAAI,CAACZ,UAAU,KAAK,SAAS,EAAE;MACjC,IAAI;QACF,IAAIC,YAAY,CAACQ,KAAK,EAAEC,OAAO,CAAC;MAClC,CAAC,CAAC,OAAOL,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC7D;IACF;;IAEA;IACA;IACA;IACA;EACF;;EAEA;EACAQ,oBAAoBA,CAACC,WAAW,EAAE;IAChC,IAAI,CAACA,WAAW,IAAI,CAACA,WAAW,CAACC,IAAI,EAAE;IAEvC,IAAI;MACF,MAAMC,eAAe,GAAG,IAAIC,IAAI,CAACH,WAAW,CAACC,IAAI,CAAC;MAClD,MAAM,CAACG,KAAK,EAAEC,OAAO,CAAC,GAAGL,WAAW,CAACM,SAAS,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;MACrEP,eAAe,CAACQ,QAAQ,CAACN,KAAK,EAAEC,OAAO,CAAC;;MAExC;MACA,IAAIM,gBAAgB;MACpB,IAAI,IAAI,CAAC5B,SAAS,EAAE;QAAA,IAAA6B,oBAAA;QAClBD,gBAAgB,GAAG,IAAIR,IAAI,CAACA,IAAI,CAACU,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QACjDxB,OAAO,CAACC,GAAG,CAAC,uCAAAsB,oBAAA,GAAsCZ,WAAW,CAACc,OAAO,cAAAF,oBAAA,uBAAnBA,oBAAA,CAAqBG,IAAI,gBAAgB,CAAC;MAC9F,CAAC,MAAM;QACL;QACAJ,gBAAgB,GAAG,IAAIR,IAAI,CAACD,eAAe,CAACc,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;MACzE;MAEA,MAAMH,GAAG,GAAG,IAAIV,IAAI,CAAC,CAAC;;MAEtB;MACA,IAAIQ,gBAAgB,GAAGE,GAAG,EAAE;QAC1B,MAAMI,qBAAqB,GAAGN,gBAAgB,CAACK,OAAO,CAAC,CAAC,GAAGH,GAAG,CAACG,OAAO,CAAC,CAAC;QACxE3B,OAAO,CAACC,GAAG,CAAC,+BAA+B2B,qBAAqB,aAAa,CAAC;;QAE9E;QACA,MAAMC,cAAc,GAAGC,UAAU,CAAC,MAAM;UACtC,IAAI,CAACC,gBAAgB,CAACpB,WAAW,CAAC;QACpC,CAAC,EAAEiB,qBAAqB,CAAC;QAEzB,IAAI,CAACpC,aAAa,CAACwC,IAAI,CAAC;UACtBC,EAAE,EAAEJ,cAAc;UAClBlB,WAAW;UACXuB,IAAI,EAAEZ;QACR,CAAC,CAAC;QAEF,OAAOO,cAAc;MACvB,CAAC,MAAM;QACL7B,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;MACjE;IACF,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACxD;IAEA,OAAO,IAAI;EACb;;EAEA;EACAiC,kBAAkBA,CAACN,cAAc,EAAE;IACjCO,YAAY,CAACP,cAAc,CAAC;IAC5B,IAAI,CAACrC,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC6C,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACL,EAAE,KAAKJ,cAAc,CAAC;EAC9E;;EAEA;EACAE,gBAAgBA,CAACpB,WAAW,EAAE;IAC5B,IAAI;MAAA,IAAA4B,iBAAA,EAAAC,qBAAA,EAAAC,qBAAA;MACF;MACA,MAAMC,qBAAqB,GAAG/B,WAAW,CAACgC,QAAQ,IAChDhC,WAAW,CAACiC,IAAI,IAChBhD,MAAM,CAACiD,YAAY,CAACC,OAAO,CAAC,QAAQ,CAAC,KAAKnC,WAAW,CAACgC,QAAQ,CAACI,GAAG;;MAEpE;MACA,MAAMzC,KAAK,GAAGoC,qBAAqB,GAC/B,6BAA6B,EAAAH,iBAAA,GAAA5B,WAAW,CAACiC,IAAI,cAAAL,iBAAA,uBAAhBA,iBAAA,CAAkBb,IAAI,KAAI,QAAQ,EAAE,GACjE,yBAAyB,EAAAc,qBAAA,GAAA7B,WAAW,CAACc,OAAO,cAAAe,qBAAA,uBAAnBA,qBAAA,CAAqBd,IAAI,KAAI,aAAa,EAAE;MAEzE,MAAMlB,IAAI,GAAGkC,qBAAqB,GAC9B,kDAAkD/B,WAAW,CAACM,SAAS,GAAG,GAC1E,yBAAyB,EAAAwB,qBAAA,GAAA9B,WAAW,CAACgC,QAAQ,cAAAF,qBAAA,uBAApBA,qBAAA,CAAsBf,IAAI,KAAI,UAAU,oBAAoBf,WAAW,CAACM,SAAS,GAAG;MAEjH,MAAMV,OAAO,GAAG;QACdC,IAAI;QACJC,IAAI,EAAE;MACR,CAAC;MAEDT,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEK,KAAK,CAAC;;MAE3C;MACA,IAAI,IAAI,CAACT,UAAU,KAAK,SAAS,EAAE;QACjC,IAAIC,YAAY,CAACQ,KAAK,EAAEC,OAAO,CAAC;MAClC;;MAEA;MACAnB,KAAK,CAAC4D,IAAI,CAAC1C,KAAK,GAAG,IAAI,GAAGC,OAAO,CAACC,IAAI,EAAE;QACtCyC,SAAS,EAAE,KAAK,CAAC;MACnB,CAAC,CAAC;IACJ,CAAC,CAAC,OAAO/C,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD;MACAd,KAAK,CAAC4D,IAAI,CAAC,kCAAkC,EAAE;QAC7CC,SAAS,EAAE;MACb,CAAC,CAAC;IACJ;EACF;;EAEA;EACAC,gCAAgCA,CAACC,YAAY,EAAE;IAC7C,IAAI,CAACA,YAAY,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;IAEnD,IAAI;MACF;MACA,IAAI,CAAC,IAAI,CAAC1D,WAAW,EAAE;QACrB,IAAI,CAACU,UAAU,CAAC,CAAC;MACnB;;MAEA;MACA,IAAI,CAACmD,qBAAqB,CAAC,CAAC;;MAE5B;MACA,MAAMC,oBAAoB,GAAGJ,YAAY,CAACd,MAAM,CAAC1B,WAAW,IAC1DA,WAAW,CAAC6C,MAAM,KAAK,WAAW,IAClC,IAAI1C,IAAI,CAACH,WAAW,CAACC,IAAI,CAAC,GAAG,IAAIE,IAAI,CAAC,CACxC,CAAC;MAEDd,OAAO,CAACC,GAAG,CAAC,gCAAgCsD,oBAAoB,CAACE,MAAM,wBAAwB,CAAC;MAEhGF,oBAAoB,CAACG,OAAO,CAAC/C,WAAW,IAAI;QAC1C,IAAI,CAACD,oBAAoB,CAACC,WAAW,CAAC;MACxC,CAAC,CAAC;;MAEF;MACA,IAAI4C,oBAAoB,CAACE,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC/D,SAAS,EAAE;QACvDoC,UAAU,CAAC,MAAM;UACf,IAAI,CAACzB,oBAAoB,CAAC,CAAC;QAC7B,CAAC,EAAE,IAAI,CAAC;MACV;IACF,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdF,OAAO,CAACE,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;IACrE;EACF;;EAEA;EACAoD,qBAAqBA,CAAA,EAAG;IACtB,IAAI,CAAC9D,aAAa,CAACkE,OAAO,CAACC,YAAY,IAAI;MACzCvB,YAAY,CAACuB,YAAY,CAAC1B,EAAE,CAAC;IAC/B,CAAC,CAAC;IACF,IAAI,CAACzC,aAAa,GAAG,EAAE;IACvBQ,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;EAC1C;AACF;;AAEA;AACA,MAAM2D,mBAAmB,GAAG,IAAIvE,mBAAmB,CAAC,CAAC;AAErD,eAAeuE,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}